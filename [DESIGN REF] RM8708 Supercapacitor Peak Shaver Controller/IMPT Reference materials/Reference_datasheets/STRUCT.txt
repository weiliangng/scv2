struct obj {
long* ptr余
long id余
}

void blah(struct obj* obj_ptr) {
obj_ptr->id = 20余
obj_ptr->ptr = &obj_ptr->id余//((arrow take precedence over &)),so &(obj_ptr->id) means address of the id member of the struct pointed to by optr.
}

//obj_ptr->ptr: Accesses the ptr member of the struct pointed to by optr
//JUST DRAW THE DAMN BOXES



STRUCT

In C, we can define a compound data type using a structure, through the C keyword struct. The syntax looks like this:

struct matrix {
  double** array;
  long num_of_rows;
  long num_of_columns;
};

struct circle {
  double x_of_center;
  double y_of_center;
  double radius;
};

Just like a variable, a struct is valid within the block it is declared in. 
Let's see an example of how we can declare and initialize a structure variable:


struct module cs1010;
cs1010.code = "CS1010";
cs1010.title = "Programming Methodology";
cs1010.mc = 4;

Note that we use . to access each member.
An alternative is to use a compound literal:
compound literal is convenient as uninitialized members are set to 0 (similar to initializers of arrays).

struct module cs1010 = {
  .code = "CS1010",
  .title = "Programming Methodology",
  .mc = 4
};

read and write to individual members of a structure variable just like any other variable:
cs1010.mc = hours_spent_per_week/2.5;
cs1010_println_long(cs1010.mc);

We can assign one structure variable to another.equivalent to assigning each member of the struct individually.
struct module cs1010s = cs1010;

Structure as Parameters
We can pass a structure variable into a function, struct is called by value, i.e., it is copied onto the call stack of the function.
Hence, the code below does not actually update the MCs of CS1010:

void update_mc(struct module cs1010, long hours_spent_per_week) {
  cs1010.mc = hours_spent_per_week/2.5;
}

To call a structure by reference, we can pass in its pointer.
void update_mc(struct module *cs1010, long hours_spent_per_week) {
  (*cs1010).mc = hours_spent_per_week/2.5;
  cs1010->mc = hours_spent_per_week/2.5;//EQUIVALENT
}

Since this is efficient, C provides another syntax for accessing the member of a structure through its pointer, using the "arrow" notation"
void update_mc(struct module *cs1010, long hours_spent_per_week) {
  cs1010->mc = hours_spent_per_week/2.5;
}


A function can return a structure. Here is how we use struct to return more than one values:
//DEFINE STRUCT
struct answer {
  long max_n;
  long max_num_steps;
};
//END DEFINE STRUCT

//FUNCTION DEF
struct answer find_max_steps(long n) {
  struct answer ans = {//INIT STRUCT
    .max_n = 1,
    .max_num_steps = 0
  };
  for (long i = 1; i <= n; i += 1) {
    long num_of_steps = count_num_of_steps(i);
    if (num_of_steps >= ans.max_num_steps) {
      ans.max_n = i;
      ans.max_num_steps = num_of_steps;
    }
  }
  return ans;//the structure gets copied back to the caller.
}

When a function returns a struct, the structure gets copied back to the caller.

Defining a Structure as a Type
typedef unsigned long person_t;
void is_contact(person_t i, person_t j);

Using typedef on struct frees us from typing the word struct every time. 

typedef struct module {
  char *code;
  char *title;
  long mc;
} module;

or

typedef struct {
  char *code;
  char *title;
  long mc;
} module;

In either case, we can just use module like any other type:

void update_mc(module cs1010, long hours_spent_per_week) {
  cs1010.mc = hours_spent_per_week/2.5;
}


